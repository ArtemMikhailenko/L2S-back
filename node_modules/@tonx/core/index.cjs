"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// packages/core/src/index.ts
var src_exports = {};
__export(src_exports, {
  AbstractProvider: () => AbstractProvider,
  AbstractSigner: () => AbstractSigner,
  BaseSigner: () => BaseSigner,
  JsonRpcProvider: () => JsonRpcProvider,
  TONXJsonRpcProvider: () => TONXJsonRpcProvider
});
module.exports = __toCommonJS(src_exports);

// packages/core/src/providers/abstract-provider.ts
var AbstractProvider = class {
  constructor() {
  }
  async _perform(action) {
    throw `${action.method} not implemented`;
  }
  async #perform(action) {
    const perform = this._perform(action);
    return await perform;
  }
  get provider() {
    return this;
  }
  async getMasterChainInfo() {
    return await this.#perform({ method: "getMasterchainInfo" });
  }
};

// packages/core/src/utils/http-fetch-client.ts
var import_axios = __toESM(require("axios"));
var HttpFetchClient = class {
  constructor(options) {
    this.client = import_axios.default.create(options);
  }
  async send(payload) {
    const response = await this.client.post("", payload);
    if (response.status !== 200)
      throw new Error("Request failed");
    return response.data.result;
  }
};

// packages/core/package.json
var version = "1.2.0";

// packages/core/src/providers/provider-jsonrpc.ts
var JsonRpcProvider = class extends AbstractProvider {
  #httpFetchClient;
  #nextId = 1;
  #network;
  constructor() {
    super();
  }
  init(options) {
    if (options.httpFetchClient) {
      this.#httpFetchClient = options.httpFetchClient;
    } else {
      this.#httpFetchClient = new HttpFetchClient({
        baseURL: options.baseURL,
        headers: {
          "x-sdk-version": version,
          "x-source": "tonx-provider"
        }
      });
    }
    this.#network = options.network;
    this.#nextId = 1;
  }
  async _send(payload) {
    const response = await this.#httpFetchClient.send(payload);
    return response;
  }
  send(method, params) {
    return this._send({ method, params, id: this.#nextId++, jsonrpc: "2.0" });
  }
  getRpcRequest(action) {
    switch (action.method) {
      case "getMasterchainInfo":
        return {
          method: "getMasterchainInfo",
          params: []
        };
      default:
        return null;
    }
  }
  async _perform(action) {
    const request = this.getRpcRequest(action);
    if (request) {
      return await this.send(request.method, request.params);
    }
    return super._perform(action);
  }
};

// packages/core/src/providers/provider-jsonrpc-tonx.ts
var import_zod = require("zod");
var version2 = "v2";
var TONXJsonRpcProvider = class extends JsonRpcProvider {
  constructor(options) {
    super();
    const { network, apiKey, httpClientOptions } = options;
    this.apiKey = apiKey;
    this.network = network;
    this.httpClientOptions = httpClientOptions;
    this.initDefaultEndpoint();
  }
  initDefaultEndpoint() {
    this.init({
      network: this.network,
      httpFetchClient: new HttpFetchClient({
        baseURL: `https://${this.network}-rpc.tonxapi.com/${version2}/json-rpc/${this.apiKey}`,
        ...this.httpClientOptions
      })
    });
  }
  async performWithLabsEndpoint(action) {
    const labsClient = new HttpFetchClient({
      baseURL: `https://${this.network}-rpc.tonxapi.com/${version2}/labs/${this.apiKey}`,
      ...this.httpClientOptions
    });
    const request = this.getRpcRequest(action);
    if (!request) {
      throw new Error(`Method ${action.method} not implemented`);
    }
    const response = await labsClient.client.post("", {
      id: 1,
      jsonrpc: "2.0",
      method: request.method,
      params: request.params
    });
    return response.data.result;
  }
  getRpcRequest(action) {
    switch (action.method) {
      case "getAccountBalance":
        return { method: "getAccountBalance", params: action.params };
      case "getTransactions":
        return { method: "getTransactions", params: action.params };
      case "getJettonBurns":
        return { method: "getJettonBurns", params: action.params };
      case "getJettonMasters":
        return { method: "getJettonMasters", params: action.params };
      case "getJettonTransfers":
        return { method: "getJettonTransfers", params: action.params };
      case "getJettonWallets":
        return { method: "getJettonWallets", params: action.params };
      case "getMessages":
        return { method: "getMessages", params: action.params };
      case "getNftCollections":
        return { method: "getNftCollections", params: action.params };
      case "getNftItems":
        return { method: "getNftItems", params: action.params };
      case "getNftTransfers":
        return { method: "getNftTransfers", params: action.params };
      case "estimateFee":
        return { method: "estimateFee", params: action.params };
      case "getAddressInformation":
        return { method: "getAddressInformation", params: action.params };
      case "getAddressState":
        return { method: "getAddressState", params: action.params };
      case "getBlockHeader":
        return { method: "getBlockHeader", params: action.params };
      case "getBlockTransactions":
        return { method: "getBlockTransactions", params: action.params };
      case "getConsensusBlock":
        return { method: "getConsensusBlock", params: {} };
      case "getExtendedAddressInformation":
        return {
          method: "getExtendedAddressInformation",
          params: action.params
        };
      case "getMasterchainBlockSignatures":
        return {
          method: "getMasterchainBlockSignatures",
          params: action.params
        };
      case "getTokenData":
        return { method: "getTokenData", params: action.params };
      case "runGetMethod":
        return { method: "runGetMethod", params: action.params };
      case "sendMessage":
        return { method: "sendMessage", params: action.params };
      case "getBocStatus":
        return { method: "getBocStatus", params: action.params };
      case "verifyBoc":
        return { method: "verifyBoc", params: action.params };
      case "radixConversion":
        return { method: "radixConversion", params: action.params };
      case "binaryConversion":
        return { method: "binaryConversion", params: action.params };
      case "detectAddress":
        return { method: "detectAddress", params: action.params };
      case "getMasterchainInfo":
        return { method: "getMasterchainInfo", params: {} };
      case "getTgBTCConfig":
        return { method: "getTgBTCConfig", params: {} };
      case "getTgBTCBalance":
        return { method: "getTgBTCBalance", params: action.params };
      case "getTgBTCMasterAddress":
        return { method: "getTgBTCMasterAddress", params: {} };
      case "getTgBTCHolders":
        return { method: "getTgBTCHolders", params: action.params };
      case "getTgBTCBurns":
        return { method: "getTgBTCBurns", params: action.params };
      case "getTgBTCWalletAddressByOwner":
        return { method: "getTgBTCWalletAddressByOwner", params: action.params };
      case "getTgBTCTransferPayload":
        return { method: "getTgBTCTransferPayload", params: action.params };
      case "getTgBTCMetaData":
        return { method: "getTgBTCMetaData", params: {} };
      case "getTgBTCTransfers":
        return { method: "getTgBTCTransfers", params: action.params };
      default:
        return super.getRpcRequest(action);
    }
  }
  async getAccountBalance(address) {
    return await this._perform({
      method: "getAccountBalance",
      params: { address }
    });
  }
  async getTransactions(params = {}) {
    return await this._perform({
      method: "getTransactions",
      params
    });
  }
  async getJettonBurns(params = {}) {
    return await this._perform({
      method: "getJettonBurns",
      params
    });
  }
  async getJettonMasters(params = {}) {
    return await this._perform({
      method: "getJettonMasters",
      params
    });
  }
  async getJettonTransfers(params = {}) {
    return await this._perform({
      method: "getJettonTransfers",
      params
    });
  }
  async getJettonWallets(params = {}) {
    return await this._perform({
      method: "getJettonWallets",
      params
    });
  }
  async getMessages(params = {}) {
    return await this._perform({
      method: "getMessages",
      params
    });
  }
  async getNftCollections(params = {}) {
    return await this._perform({
      method: "getNftCollections",
      params
    });
  }
  async getNftItems(params = {}) {
    return await this._perform({
      method: "getNftItems",
      params
    });
  }
  async getNftTransfers(params = {}) {
    return await this._perform({
      method: "getNftTransfers",
      params
    });
  }
  async estimateFee(params = {}) {
    return await this._perform({
      method: "estimateFee",
      params
    });
  }
  async getAddressInformation(address) {
    return await this._perform({
      method: "getAddressInformation",
      params: { address }
    });
  }
  async getAddressState(address) {
    return await this._perform({
      method: "getAddressState",
      params: { address }
    });
  }
  async getBlockHeader(params) {
    return await this._perform({
      method: "getBlockHeader",
      params
    });
  }
  async getBlockTransactions(params) {
    return await this._perform({
      method: "getBlockTransactions",
      params
    });
  }
  async getConsensusBlock() {
    return await this._perform({
      method: "getConsensusBlock",
      params: {}
    });
  }
  async getExtendedAddressInformation(address) {
    return await this._perform({
      method: "getExtendedAddressInformation",
      params: { address }
    });
  }
  async getMasterchainBlockSignatures(seqno) {
    return await this._perform({
      method: "getMasterchainBlockSignatures",
      params: { seqno }
    });
  }
  async getTokenData(address) {
    return await this._perform({
      method: "getTokenData",
      params: { address }
    });
  }
  async runGetMethod(params) {
    const v2Params = import_zod.z.object({
      address: import_zod.z.string(),
      method: import_zod.z.string(),
      stack: import_zod.z.optional(
        import_zod.z.array(
          import_zod.z.tuple([import_zod.z.literal("num"), import_zod.z.number()]).or(import_zod.z.tuple([import_zod.z.literal("cell"), import_zod.z.string()])).or(import_zod.z.tuple([import_zod.z.literal("slice"), import_zod.z.string()]))
        )
      )
    }).safeParse(params);
    if (v2Params.success) {
      return await this._perform({
        method: "runGetMethod",
        params: {
          address: v2Params.data.address,
          method: v2Params.data.method,
          stack: !v2Params.data.stack ? [] : v2Params.data.stack.map((eachStack) => {
            switch (eachStack[0]) {
              case "num":
                return ["num", eachStack[1].toString(10)];
              case "cell":
                return ["tvm.Cell", eachStack[1]];
              case "slice":
                return ["tvm.Slice", eachStack[1]];
            }
          })
        }
      });
    }
    const v3Params = import_zod.z.object({
      address: import_zod.z.string(),
      method: import_zod.z.string(),
      stack: import_zod.z.optional(
        import_zod.z.array(
          import_zod.z.object({ type: import_zod.z.literal("num"), value: import_zod.z.string() }).or(import_zod.z.object({ type: import_zod.z.literal("cell"), value: import_zod.z.string() })).or(import_zod.z.object({ type: import_zod.z.literal("slice"), value: import_zod.z.string() }))
        )
      )
    }).safeParse(params);
    if (v3Params.success) {
      return await this._perform({
        method: "runGetMethod",
        params: {
          address: v3Params.data.address,
          method: v3Params.data.method,
          stack: !v3Params.data.stack ? [] : v3Params.data.stack.map((eachStack) => {
            switch (eachStack.type) {
              case "num":
                if (eachStack.value.toLowerCase().startsWith("0x")) {
                  return ["num", BigInt(eachStack.value.toLowerCase()).toString(10)];
                } else {
                  return ["num", eachStack.value];
                }
              case "cell":
                return ["tvm.Cell", eachStack.value];
              case "slice":
                return ["tvm.Slice", eachStack.value];
            }
          })
        }
      });
    }
    throw new Error("Unknown type of params");
  }
  async sendMessage(boc) {
    return await this._perform({
      method: "sendMessage",
      params: { boc }
    });
  }
  async getBocStatus(boc) {
    return await this.performWithLabsEndpoint({
      method: "getBocStatus",
      params: { boc }
    });
  }
  async verifyBoc(boc) {
    return await this.performWithLabsEndpoint({
      method: "verifyBoc",
      params: { boc }
    });
  }
  async radixConversion(params) {
    return await this.performWithLabsEndpoint({
      method: "radixConversion",
      params
    });
  }
  async binaryConversion(params) {
    return await this.performWithLabsEndpoint({
      method: "binaryConversion",
      params
    });
  }
  async detectAddress(address) {
    return await this.performWithLabsEndpoint({
      method: "detectAddress",
      params: { address }
    });
  }
  async getMasterchainInfo() {
    return await this._perform({
      method: "getMasterchainInfo",
      params: {}
    });
  }
  async getTgBTCConfig() {
    return await this._perform({
      method: "getTgBTCConfig",
      params: {}
    });
  }
  async getTgBTCBalance(params) {
    return await this._perform({
      method: "getTgBTCBalance",
      params
    });
  }
  async getTgBTCMasterAddress() {
    return await this._perform({
      method: "getTgBTCMasterAddress",
      params: {}
    });
  }
  async getTgBTCHolders(params) {
    return await this._perform({
      method: "getTgBTCHolders",
      params: params ?? {}
    });
  }
  async getTgBTCBurns(params) {
    return await this._perform({
      method: "getTgBTCBurns",
      params
    });
  }
  async getTgBTCWalletAddressByOwner(params) {
    return await this._perform({
      method: "getTgBTCWalletAddressByOwner",
      params
    });
  }
  async getTgBTCTransferPayload(params) {
    return await this._perform({
      method: "getTgBTCTransferPayload",
      params
    });
  }
  async getTgBTCMetaData() {
    return await this._perform({
      method: "getTgBTCMetaData",
      params: {}
    });
  }
  async getTgBTCTransfers(params) {
    return await this._perform({
      method: "getTgBTCTransfers",
      params
    });
  }
};

// packages/core/src/signer/abstract-signer.ts
var AbstractSigner = class {
  constructor() {
  }
};

// packages/core/src/signer/base-signer.ts
var import_crypto = require("@ton/crypto");
var import_core = require("@ton/core");
var primitiveTypes = [
  "slice",
  ...Array.from({ length: 256 }, (_, i) => i + 1).map(
    (i) => `int${i}`
  ),
  ...Array.from({ length: 256 }, (_, i) => i + 1).map(
    (i) => `uint${i}`
  )
];
var isPrimitiveType = (type) => {
  return primitiveTypes.includes(type);
};
var stringTo32BitInt = async (str) => {
  const hashString = (await (0, import_crypto.sha256)(str)).toString("hex", 0, 4);
  return BigInt(`0x${hashString}`);
};
var bufferToBigInt = (buf) => {
  return BigInt(`0x${buf.toString("hex")}`);
};
var linearize = (primaryType, typesMap, found = []) => {
  if (found.includes(primaryType)) {
    return found;
  } else if (typesMap[primaryType] === void 0) {
    return found;
  }
  found.push(primaryType);
  for (const property of typesMap[primaryType].value) {
    for (const child of linearize(property.type, typesMap, found)) {
      if (!found.includes(child)) {
        found.push(child);
      }
    }
  }
  return found;
};
var TypedDataEncoder = class {
  #typesMap = {};
  #primaryType = "";
  constructor({ types }) {
    const hasParent = /* @__PURE__ */ new Set();
    for (const [type, fields] of Object.entries(types)) {
      const params = [];
      for (const field of fields) {
        params.push(`${field.type} ${field.name}`);
        if (isPrimitiveType(field.type)) {
          continue;
        }
        hasParent.add(field.type);
      }
      this.#typesMap[type] = {
        type: `${type}(${params.join(",")})`,
        value: fields
      };
    }
    for (const type of Object.keys(this.#typesMap)) {
      if (!hasParent.has(type)) {
        this.#primaryType = type;
        break;
      }
    }
  }
  #encodeType(primaryType) {
    const c3LinearResult = linearize(primaryType, this.#typesMap);
    return c3LinearResult.map((eachType) => this.#typesMap[eachType].type).join("");
  }
  async #buildDomainSeparatorHash(domain) {
    return (0, import_core.beginCell)().storeUint(
      bufferToBigInt(
        await (0, import_crypto.sha256)(
          "TEPXXDomain(uint32 name,uint32 version,int8 workchainId,uint256 verifierContract)"
        )
      ),
      256
    ).storeUint(await stringTo32BitInt(domain.name), 32).storeUint(await stringTo32BitInt(domain.version), 32).storeInt(domain.workchainId, 8).storeUint(BigInt(domain.verifierContract), 256).endCell().hash();
  }
  async #hash(data, type) {
    const { value } = this.#typesMap[type];
    const typeHash = await (0, import_crypto.sha256)(this.#encodeType(type));
    const c = (0, import_core.beginCell)();
    c.storeUint(bufferToBigInt(typeHash), 256);
    for (const field of value) {
      switch (true) {
        case field.type.startsWith("int"): {
          const bits = parseInt(field.type.replace("int", ""));
          c.storeInt(BigInt(data[field.name]), bits);
          break;
        }
        case field.type.startsWith("uint"): {
          const bits = parseInt(field.type.replace("uint", ""));
          c.storeUint(BigInt(data[field.name]), bits);
          break;
        }
        case field.type === "slice": {
          c.storeSlice(data[field.name]);
          break;
        }
        default: {
          if (!(field.type in this.#typesMap)) {
            throw new Error(`Unknown type ${field.type}`);
          }
          c.storeUint(
            bufferToBigInt(await this.#hash(data[field.name], field.type)),
            256
          );
          break;
        }
      }
    }
    return c.endCell().hash();
  }
  async hash(domain, value) {
    const [domainSeparatorHash, structHash] = await Promise.all([
      this.#buildDomainSeparatorHash(domain),
      this.#hash(value, this.#primaryType)
    ]);
    const hashedData = (0, import_core.beginCell)().storeUint(65535, 16).storeUint(bufferToBigInt(domainSeparatorHash), 256).storeUint(bufferToBigInt(structHash), 256).endCell().hash();
    return hashedData;
  }
};
var BaseSigner = class extends AbstractSigner {
  #keyPair;
  constructor({ keyPair }) {
    super();
    this.#keyPair = keyPair;
  }
  signMessage(message) {
    return typeof message === "string" ? (0, import_crypto.sign)(Buffer.from(message), this.#keyPair.secretKey) : (0, import_crypto.sign)(message, this.#keyPair.secretKey);
  }
  async signTypedData(domain, types, value) {
    const hash = await new TypedDataEncoder({ types }).hash(domain, value);
    return this.signMessage(hash);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AbstractProvider,
  AbstractSigner,
  BaseSigner,
  JsonRpcProvider,
  TONXJsonRpcProvider
});
